# Refactoring

- 코드의 기능을 바꾸지 않고, 내부 구조를 이해하기 쉽고 고치기 쉽게 개선하는 작업(소스 코드를 청소하는 활동)
- 소스 코드의 변경을 쉽게 하고, '코드의 구린내'로부터 코드를 지속적으로 깨끗하게 유지하는 방법(코드 품질을 개선하는 객체지향 사고법)
- 코딩 작업의 일부, 습관(코딩, 디버깅, 테스트, 리팩토링)
- 소스 코드의 **가독성, 재사용성, 유지보수성**을 향상시킨다.
- 성능 최적화와 상반된다.



## Refactoring의 필요성

- 소스 코드는 시간에 따라 노후화된다.(legacy code)
  - 계속적으로 발생되는 각종 요구사항의 증가와 변경으로 소스코드는 초기 설계, 의도와 맞지 않게 변형되고 왜곡되어 간다.
  - 계속 누적되는 변형, 왜곡, 덧붙이기로 인해 유지보수가 어려워지고 변경시 오류 발생 가능성이 높아진다.

### 



## Refactoring의 필요성 > 코드 정제

- 코드는 한 번에 완성되지 않는다.
  - 코딩은 글쓰기, 예술작품 처럼 생각을 실체화한 후 여러 차례 각 부분을 보완하고 다듬어야 완성된다.





## Refactoring > 나쁜 코드

- 나쁜 코드 -> 이해 불가  -> 재개발 -> 차세대 프로젝트



### 1. 나쁜 코드를 짜는 이유(청소를 하지 않는 이유)

- 시간, 일정 부족 : 무리한 프로젝트 일정, 허황된 계획
- 성숙하지 못한 S/W 문화 : S/W개발 경시, 노동 집약적 S/W개발
- 개발자 잘못된 습관 : '급하니까', '대충 짜도 돌아간다', '나중에 시간 날 때'
- Ownership 부족 : '내 꺼 아니니까'



### 2. 나쁜 코드의 결과

- 소스 코드 읽는 시간 증가 -> 코드 읽는 시간(90%) vs 코드 작성 시간(10%)
- 코딩, 테스트, 디버깅 등 모든 구현 작업의 시간 증가 -> 생산성 저하, 밤샘 근무
- 코드 수정 비용 증가, 잦은 오류 발생
- 제품 업그레이드, 출시 주기 증가 -> 시장 경쟁력 상실
- 수년 내 반복되는 재구축, 차세대(해외에는 없는 개념)



### 3. 나쁜 코드를 사용하기 어려운 이유

- 코드는 서로 얽혀있다.(스파게티 코드) -> 잦은 오류 발생
- 계속되는 덧붙이기 -> 코드 복잡도 증가
- 원 개발의도와 변경된 내용 구별 불가 -> 추가적인 기능 추가, 변경 불가





## 코드의 구린내

- 중복 코드(Duplicated code)
- 장황한 메서드(Long method)
- 방대한 클래스(Large class)
  - 용도/역할별로 클래스 분할 필요
- 과다한 매개변수(Long parameter list)
  - 5개 이상
- 수정의 산발(Divergent change)
  - 클래스가 다양한 원인, 다양한 바익으로 수정될 때
- 기능의 산재(Shotgun surgery)
  - 수정할 때마다 여러 클래스를 고쳐야할 때
- 잘못된 소속(Feature Envy)
  - 필드, 메서드가 다른 클래스에 더 많이 사용될 때
- 데이터 뭉치(Data Clumps)
- Switch 문
  - 객체지향 언어에서 switch문 재정의 필요
- 직무유기 클래스(Lazy class)
  - 쓸모없어진 클래스 정리
- 막연한 범용 코드(Speculative Generality)
  - 용도 불명확
  - 의미가 막연한 변수/메소드명 (명명규칙의 중요성)
- 임시 필드(Temporary field)
- 메시지 체인(Message chains)
  - 다수의 객체가 연쇄적인 요청이 발생할 때
- 과잉 중개 메서드(Midle Man)
  - 기능이 많은 메서드
- 지나친 관여(Inappropriate Intimacy)
- 인터페이스가 다른 대용 클래스
- 미흡한 라이브러리 클래스(Incomplete library class)
- 데이터 클래스(Data class)
- 방치된 상속물(Refused bequest)
- 불필요한 주석(comments)



## Refactoring의 효과

- 소프트웨어 설계가 개선된다.
  - 부적합한 위치에 있는 코드를 제거하거나 적합한 위치로 이동
  - 중복 코드 제거
- 소프트웨어를 이해하기 쉬워진다.
  - 소스 코드는 모든 팀원들과 공유된다.
  - 코딩 작업 중 가장 많은 시간이 소요되는 시간이 소스 코드를 읽는 시간이다.
- 버그 찾기가 쉬워진다.
  - 코드 이해가 쉬워지면 버그 발견도 쉬워진다.
- 프로그래밍 속도가 빨라진다.
  - 깔끔한 설계, 정리된 코드는 개발 속도를 향상 시킨다.





## Refactoring의 목표 > Clean Code

### 1. Clean Code의 작성 원칙

- 읽기 쉽게 작성 (가독성)
  - 잘 쓰여진 글을 읽는 것처럼 자연스럽게 읽혀진다.
  - 이해하기 쉬운 용어를 사용한다.
- 간단하게 작성 (단순성)
  - 한 번에 한가지 로직/처리만 수행한다.
  - 클래스/메서드를 최소 단위로 분리한다.
- 영향도 최소화 (의존성)
  - 변경되는 부분이 다른 부분에 영향을 주지 않는다.
  - 모듈화 (응집도 최대, 결합도 최소)
- 중복 최소화 (중복성)
  - 코드 내에 중복이 없다.
  - 공통된 코드 부분 -> 공통 클래스/메서드화
- 작게 추상화
  - 코드 내의 클래스/메스드 등의 동일한 수준의 추상화를 갖고 있다.
  - 상세 내용은 하위 클래스/메서드에서 구현





## Refactoring은 언제 필요한가

- 따로 시간내서 하지 않고 평소 틈틈히 해야한다.
- 같은 작업을 3번째 반복하게 됐을 때 실시힌다.
- 기능을 추가할 때 실시한다.
  - 코드를 깔끔하게 만드는 과정에서 더 깊이 코드를 이해하게 된다.
- 버그를 수정할 때 실시한다.
  - 버그를 찾기 쉬워지고 버그를 발생 시킨 코드 내용을 개선시킨다.
- 코드를 검수할 때 실시한다.
  - Pair Programming
  - Code review
  - Code Inspection



## Refactoring의 절차

1. 테스트 코드 작성
2. 프로그램 순서 정리 (flow chart)
3. 프로그램 내 메서드, 변수 이름 변경
   - 프로젝트 내 표준용어 사용 (용어 사전)
   - 시스템 내 명명규칙 준수
4. 프로그램을 처리 내용에 따라 재조정
   - 메서드 분리/조정, 클래스 분리/조정
5. 중복 제거, 영향도 최소화
   - 공통 부분(library 영역), 개발자 영억(업무별 변경 영역) 분리
6. 코드 단순화, 구조 변경(조건문, 메서드 호출)





## Refactoring의 기본 원리

- 객체지향의 개념(추상화, 상속, 캡슐화, 다형성)을 기본 원리로 하여 수행
- 테스트 코드 작성
  - 리팩토링 후 소스 코드의 정상 동작 여부를 지속적으로 확인하기 위해





### 출처

- KOSTA에서 진행했던 리팩토링 강의 교재 (강사님 : 엄기영)