# Legacy

- 유산



# Legacy Code

- 하위 호환을 위해 새로운 프로그램 속에 남겨두는 기존의 소스 코드
- 낡은, 기존의 Code

- 주로 부정적인 의미로 사용
- 예
  - 다른 코드와의 개연성을 무시한 채 Due Date만 맞춰 작성한 코드
  - 코드의 종속성, 디펜던시를 낮추는 노력이 없는 코드
  - 주석을 전혀 남기지 않아 수정 및 보완이 어려운 코드
  - 기능 단위의 함수 혹은 모듈 자체가 지나치게 큰 코드



## 1. Legacy code의 필요성

- 기존의 소스 코드를 모두 삭제하거나 수정해버리면, 기존 기능을 사용하지 못하는 사태 발생
  - 온라인 전용 프로그램 : 강제 업데이트
  - 오프라인 전용 프로그램 : 강제 업데이트가 불가능 -> 업데이트 전 버전으로도 작동되도록 하위 호환을 제공해 줄 필요가 있다.
  - 새 시스템과 기존 시스템이 상충될 경우 기존 시스템을 버리는 게 아니라 새 시스템을 도입하지 않는 선택을 하게 되기도 한다.



## 2. Legacy code의 문제점

#### (1) 기존의 오류를 짊어지고 가야 한다.

- 기존 시스템이 갖고 있던 버그 등의 문제를 새로운 버전에서도 그대로 짊어지고 가야한다.



#### (2) 신규 프로그램과 레거시 프로그램 동시 운영

- 새로운 기술과 프로그래머의 솜씨를 사용한 새롭고 보다 효율적인 코드로 변환하는 동안에도 레거시 프로그램을 계속 운영시켜야 한다.



#### (3) 복잡도 증가 및 신규 추가 코드와의 충돌

- 하위 호환을 위해 지속적으로 추가되는 소스 코드가 세월이 흐를 수록 프로그램 내부에 쌓이고 쌓여 소스 코드가 지나치게 복잡해지고, 충돌 등의 새로운 문제를 일으키기도 한다.



#### (4) 코드 수정이 어렵다.

- 기능 수정이나 추가 발생 시, 이 영향이 프로그램의 어느 부분까지 미칠지 예상하기 어렵다.



#### (5) 코드 파악이 어렵다.

- legacy code는 제대로 리팩토링이 되어있지 않은 경우가 대부분이다.

  리팩토링 되어있는 코드는 같은 레벨의 추상화된 메소드를 가지고 있다. 

  그렇기 때문에 메소드만 봐도 input 값에 따른 output 값을 짐작 가능하다.

  하지만 legacy code는 이러한 추상화가 제대로 되어있지 않기 때문에 남이 작성해놓은 코드는 물론

  자기가 작성한 코드도 시간이 지난 이후에는 현저히 가독성이 떨어진다.

  따라서 추후 코드 분석 시 어려움을 겪을 수 있다.



### 

# Refactoring

- 기능을 바꾸지 않고 내부 구조를 개선하는 것
- Legacy code 개선을 위한 방법





### 참고 link

- https://namu.wiki/w/%EB%A0%88%EA%B1%B0%EC%8B%9C
- https://webisfree.com/2017-11-23/%EB%A0%88%EA%B1%B0%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80
- https://jhleed.tistory.com/12